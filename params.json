{"name":"ggx","body":"How To Retarget the GNU Toolchain in 21 Patches\r\n===============================================\r\n\r\nPreamble to the github Edition\r\n------------------------------\r\n\r\nThe text below was originally written for a series of daily blog posts\r\nI wrote in 2008 about porting the GNU Toolchain to a new target.  The\r\nold blog site is down, so I have collected and re-hosted the articles\r\nhere at github with all of the original source patches.\r\n\r\nIn retrospect, some of the original thinking behind this project was\r\nnaive, however the end result was an interesting and useful project\r\nthat I hope others may learn from.\r\n\r\nThe source patches apply to 2008-era GCC and SRC trees for the GNU\r\nToolchain.  They may not be useful from a development perspective\r\ntoday, but as a teaching tool they still have value.\r\n\r\nThe experimental 'ggx' target was eventually renamed to 'moxie', and\r\nwork continues here:\r\n* http://moxielogic.org/blog\r\n* http://moxielogic.org/wiki\r\n* http://github.com/atgreen/moxiedev\r\n\r\nI'd love to hear from people who found this useful or who have\r\nquestions.  I can be reached at green@moxielogic.com.\r\n\r\nHappy Hacking!\r\n\r\n**Anthony Green**\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPreamble: Top-Down ISA Evolution\r\n---------------------------------\r\n\r\nThe design process of an Instruction Set Architecture (ISA) has always\r\nstruck me as being backwards. I imagine that they are mostly designed\r\nby hardware engineers whose decisions are largely influenced by the\r\nmedium in which they work - hardware description languages. Every\r\ndecision is influenced to some degree by implementation difficulty or\r\nlimitations of the hardware.\r\n\r\nOnly the lucky compiler developers have a chance to review an ISA\r\nbefore it is fixed in stone. The few times I've seen this happen it\r\nhas always been to everyone's benefit. Perhaps there are instructions\r\nthat the compiler could never use, or perhaps the compiler would\r\ngenerate better code if only it had some overlooked addressing mode.\r\n\r\nI've often wondered what would happen if we reversed this\r\nprocess. What would an ISA look like that was solely influenced by the\r\nneeds of the compiler writer, without regard to the hardware side of\r\nthe house? Instead of designing from the hardware up, start from the\r\ncompiler and design top-down.\r\n\r\nAs an experiment, I've developed the start of a GNU tools port to a\r\nnew architecture that was wholly undefined at the start of the\r\nproject. There was no instruction set architecture definition, no\r\nregister file definition, no defined ABI or OS interfaces. Instead, I\r\ndefined these things on the fly, letting things evolve naturally based\r\non the needs of the compiler. The C compiler, assembler, linker,\r\nbinutils and simulator were developed concurrently. So, for instance,\r\nwhen the compiler required an \"add\" instruction, each tool would be\r\ntaught about \"add\" and so on.\r\n\r\nI'm going to blog a patch a day to show my progress. Each patch will\r\nbe small and buildable. I hope to show that you can get from nothing\r\nto running real programs using this top-down ISA design method in a\r\nsurprisingly short amount of time.\r\n\r\nA couple of caveats first... I am not an experienced compiler\r\nwriter. I've been involved in many new GNU ports over the years at\r\nCygnus and Red Hat, but mostly in a bizdev capacity. I have a good\r\nidea how all the pieces go together, but this will be my first attempt\r\nat it and I'm certain to botch some things. Second, I'm by no means an\r\nexpert in ISA design. I'm taking the lazy man's route to ISA design:\r\n\r\n1. Try to build something with gcc\r\n2. See what the compiler is complaining about\r\n3. Implement it\r\n4. Go to 1.\r\n\r\nEvery design decision is driven by whatever is easiest to\r\nimplement. What I expect I'll end up with is a simple although wildly\r\ninefficient architecture. Then perhaps we can optimize this toy ISA\r\nbased on real-world code generation. At the end of the day, however,\r\nmy goal is for this to be a fun and interesting experiment.\r\n\r\nI'll post my first patch later today. \r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\n\r\nPatch 1: Naming the Target\r\n-------------------------\r\n\r\nThe GNU tools are maintained in two separate repositories: src and\r\ngcc. The src tree contains the GNU binutils, gdb, instruction set\r\nsimulators, cgen, newlib (a C runtime library), winsup (cygwin runtime\r\nsupport) and more. The gcc tree contains the GNU compiler collection\r\nand related utilities. These trees are designed to be merged into a\r\nsingle tree (sometimes called a Cygnus tree) so you can configure and\r\nbuild the entire toolchain in one go.\r\n\r\nThose of you interested in some history might want to read the mostly\r\naccurate article and thread here:\r\nhttp://www.sourceware.org/ml/gdb/2000-09/msg00009.html.\r\n\r\nI'm not going to build everything from a merged tree. The unfortunate\r\ntruth is that shared top level files in the two trees often get out of\r\nsync with one another. For instance, sometimes the trees depend on\r\nincompatible versions of the autotools and keeping everything happy\r\ntogether is more work that I care to do at this point.\r\n\r\nNow that we've decided on two trees, I'm going to start in the src\r\ntree.\r\n\r\nThe only thing we need to decide at this point is the architecture's\r\nname. I'm calling this \"ggx\" for now.\r\n\r\nThe patch after the jump adds the top level configury for our port. It\r\njust tells the build system to recognize our target name, and to not\r\nconfigure/build any of the subdirectories requiring target specific\r\nwork.\r\n\r\nOnce patched, you should be able to configure and build the toolchain\r\nlike so:\r\n\r\n    $ ./configure --target=ggx-elf\r\n    $ make\r\n\r\nThe \"ggx-elf\" target simply tells the build system that we want a\r\ntoolchain to generate ELF object files for the ggx architecture.\r\n\r\nThe only thing this builds are some support libraries for the host\r\nsystem. It's not much, but it's a start!\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-01-src.patch\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPatch 2: BFD!\r\n-------------\r\n\r\nToday we'll build BFD, which is a library for reading and writing\r\nobject files. We're mostly concerned with ELF, but BFD handles a\r\nnumber of other formats as well.\r\n\r\nBFD is a backronym for Binary File Descriptor, but we all know it\r\noriginally stood for Big F'ing Deal. The BFD manual puts it thusly:\r\n\r\n> The name came from a conversation David Wallace was having with Richard Stallman about the library: RMS said that it would be quite hard--David said \"BFD\". Stallman was right, but the name stuck.\r\n\r\nDavid Henkel-Wallace (aka Gumby) was one of Cygnus' founders, and, at\r\nleast as I recall, his California license plate at one time was \"GNU\r\nBFD\".\r\n\r\nNow we have to make some real decisions about the ggx architecture,\r\nbut not very difficult ones. The most significant features we're\r\ncommitting to in this patch are 32-bit words, 32-bit addresses and\r\n8-bit bytes (see cpu-ggx.c). Two reasons for picking these values: \r\n\r\n1. the GNU tools are really good at targeting 32-bit systems and \r\n2. 8- and 16-bit systems won't run any interesting Free Software.\r\n\r\nAlso note that we're defining the ELF machine number for ggx (0xFEED\r\nin include/elf/common.h). This number is encoded in all ggx object\r\nfiles and executables so other tools (objdump, gdb, etc) can identify\r\nthem as such. There's a standards body somewhere that maintains the\r\nmaster list of ELF machine numbers. I just picked a random number\r\nright now, but it's something you need to worry about if you start\r\nworking with other tool vendors for your processor (JTAG hardware\r\ndebuggers, for instance).\r\n\r\nApply this patch to your src tree, rebuild, and you'll have a\r\nlibbfd. There's really not much to it. Most of this patch is made up\r\nof configury changes. Click on the link below to see the patch.\r\n\r\nWe're very close to having a working assembler for ggx. There's just\r\none more infrastructure step to take care of first.\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-02-src.patch\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPatch 3: Bad Instructions\r\n-------------------------\r\n\r\nMuch like yesterday's BFD patch, the patch below is mostly\r\nconfigury. It builds the opcodes library for our new target: the ggx\r\nmachine.\r\n\r\nThe opcodes library describes how instructions are encoded in memory\r\nand how to disassemble them into text. It's used by tools like\r\nobjdump, gdb and gas.\r\n\r\nAnd, finally, details of our future architecture are beginning to\r\nemerge. This patch defines the first ggx instruction: \"bad\". This\r\ninstruction represents an illegal opcode, and should issue something\r\nlike an illegal instruction trap if we ever attempt to execute it.\r\n\r\nThere's no real reason to ever write a program with a \"bad\"\r\ninstruction, but there's no avoiding defining it either. We need well\r\ndefined behaviour when the core attempts to decode an undefined\r\ninstruction. In truth, there are many \"bad\" instruction variants: one\r\nfor each undefined opcode. It just so happens that they are all \"bad\"\r\nright now!\r\n\r\nWe haven't written anything yet about how opcodes are encoded, or even\r\nhow wide the instructions are. If you look carefully at the\r\ndisassembler in ggx-dis.c you'll see that we're just pulling single\r\nbyte \"instructions\" out of memory and looking them up in an opcode\r\ntable. This is just scaffolding and will be replaced with a real\r\ninstruction decoder shortly.\r\n\r\nBefore we do that, we'll take our first major step tomorrow by\r\ncreating a working assembler.\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-03-src.patch\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPatch 4: Cooking with GAS\r\n-------------------------\r\n\r\nToday's patch to the src tree will let us build the GNU Assembler,\r\ngas, for the ggx architecture. You may recall from yesterday's post\r\nthat we've defined our first and only instruction: \"bad\". This\r\nassembler will let us create our first object file of bad code.\r\n\r\nTwo routines of note are md_begin(), which populates a hashtable with\r\nall of our opcodes (only one so far), and md_assemble(), which parses\r\nggx assembly text to convert into binary.\r\n\r\nThe only thing you need to worry about in md_assemble() are your\r\nmachine's instructions. The rest of gas will handle things like\r\nlabels, data and pseudo-ops. Continuing with our temporary\r\nscaffolding, gas is using a single byte encoding for our \"bad\"\r\ninstruction. We'll get around to defining a proper instruction\r\nencoding in a couple of days.\r\n\r\nAs an example, here's some ggx assembly source code, which we'll\r\nassemble and examine with nm.\r\n\r\n    $ cat foo.s\r\n    .data\r\n                    .global foo\r\n    foo:            .long 0x123\r\n    bar:            .long 0x456\r\n    .text\r\n                    .global main\r\n    main:           bad\r\n                    bad\r\n                    bad\r\n    \r\n    $ ggx-elf-as foo.s\r\n    $ nm a.out\r\n    00000004 d bar\r\n    00000000 D foo\r\n    00000000 T main\r\n\r\nMy x86 Fedora nm doesn't know about the ggx architecture, but it does\r\nunderstand ELF so it's able to examine the symbols and dump them\r\ncorrectly. The host's objdump is similarly able to dump section\r\ninformation but, of course, it can't disassemble ggx instructions. We\r\nneed a ggx-elf-objdump for that, and that's what we'll build tomorrow.\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-04-src.patch\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPatch 5: binutils\r\n-----------------\r\n\r\nToday's tiny patch simply turns on the binutils directory in our src\r\ntree. This gives us the following fully functional tools:\r\nggx-elf-addr2line, ggx-elf-ar, ggx-elf-as, ggx-elf-c++filt,\r\nggx-elf-nm, ggx-elf-objcopy, ggx-elf-objdump, ggx-elf-ranlib,\r\nggx-elf-readelf, ggx-elf-size, ggx-elf-strings and ggx-elf-strip.\r\n\r\nNow we can disassemble the code we assembled yesterday:\r\n\r\n    $ ggx-elf-objdump -sd a.out\r\n    \r\n    a.out:     file format elf32-ggx\r\n    \r\n    Contents of section .text:\r\n     0000 000000                               ...             \r\n    Contents of section .data:\r\n     0000 00000123 00000456                    ...#...V       \r\n    Disassembly of section .text:\r\n    \r\n    00000000 <main>:\r\n       0:   00              bad\r\n            ...\r\n\r\nTomorrow we'll create a linker. We still only support one instruction\r\n(\"bad\"), but all of the toolchain infrastructure is starting to take\r\nshape.\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-05-src.patch\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPatch 6: The Linker\r\n-------------------\r\n\r\nToday's patch enables the GNU linker, ld.\r\n\r\nThe only architectural element we're committing to in this patch is\r\nthe basic memory architecture. We'll be using a standard von Neumann\r\narchitecture with shared text and data memory. There are some GNU\r\ntools ports to Harvard architectures, with their separate text and\r\ndata memories, but they have to play tricks in order to deal with\r\nlimitations of the tools. GDB, for instance, was never designed to\r\ndeal with situations where the instruction at address 0x1000 would be\r\ndifferent from the data at 0x1000. Our primary design goal is to make\r\nthe tools simple, which means we'll be going with the basic von\r\nNeumann.\r\n\r\nThis patch includes a simple linker script template that tells the\r\nlinker where to place sections in memory. The linker script also\r\ndefines a few important symbols for things like the base of the C\r\nruntime stack and the location and extent of the .bss section. These\r\nwill be important when we write our startup code and have to\r\ninitialize the stack pointer and clear .bss.\r\n\r\nSo now we have an assembler, linker and binutils for the ggx\r\narchitecture, but we've only defined a few things about it:\r\n\r\n* 32-bit words\r\n* 8-bit bytes\r\n* 32-bit addresses\r\n* von Neumann architecture\r\n\r\nWe've also defined a single instruction with a bogus single byte\r\nencoding. Tomorrow we'll talk about instruction encodings and\r\nimplement some basic support for encoding and decoding instructions.\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-06-src.patch\r\n\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPatch 7: Instruction Encodings\r\n------------------------------\r\n\r\nThis is where things get interesting....\r\n\r\nWhat kind of machine do we want? Here's what I have in mind:\r\n\r\n1. Load-store architecture. Operations will either work on registers\r\nand immediates or perform loads/stores to memory. This is simple and\r\nGCC is well suited for this kind of architecture.\r\n2. Variable width instructions. We're not building a high-performance\r\nRISC engine. We're just building an architecture that is simple to\r\nimplement good GCC support for. Let's ignore any non-essential\r\ncomplexity and allow for variable width-instructions. So, for\r\ninstance, loading a 32-bit immediate value into a register should just\r\nbe a single instruction (> 32-bits).\r\n3. If we're going to go with variable width instructions, let's make\r\ncode-density a secondary goal. Given this, let's default to 16-bit\r\ninstructions as the smallest instruction.\r\n\r\nDesigning instruction encodings is tricky business. I fully expect\r\nthis initial attempt to change once we see the kind of output GCC\r\ngives us. But, for now, here's a comment from the patch describing my\r\nfirst stab at two classes of instruction encodings..\r\n \r\n    /*\r\n      The ggx processor's 16-bit instructions come in two forms:\r\n    \r\n      FORM 1 instructions start with a 0 bit...\r\n    \r\n        0ooooooaaabbbccc\r\n        0              F\r\n     \r\n       oooooo - FORM 1 opcode number\r\n       aaa    - operand A\r\n       bbb    - operand B\r\n       ccc    - operand C\r\n    \r\n      FORM 2 instructions start with a 1 bit...\r\n    \r\n        1ooovvvvvvvvvvvv\r\n        0              F\r\n     \r\n       ooo          - FORM 2 opcode number\r\n       vvvvvvvvvvvv - 12-bit immediate value\r\n    */\r\n    \r\nAllowing for three operands lets us perform operations like A = B + C\r\nas one instruction (where reg ister A != register B != register\r\nC). This limits us to 3-bit operands if we want 6-bits for the\r\nopcode. Three bit operands naturally allows for 8 general purpose\r\nregisters. This puts the ggx architecture into the \"register poor\"\r\nbucket. However, it's a start, and perhaps it will change as we evolve\r\nthe architecture.\r\n\r\nAt this point I don't know if the FORM 2 instruction makes sense. Just\r\nthink of it as a place holder for now. It demonstrates one way to\r\ndivide our 16-bit instruction space into different groups of\r\ninstruction encodings.\r\n\r\nThe following patch to the src tree modifies the opcodes library to\r\nunderstand FORM 1 and FORM 2 instructions. ggx_opc_info_t is a new\r\ntype describing each instruction. We also define a few macros\r\ndescribing instruction types. For instance, GGX_F1_AB is a FORM 1\r\ninstruction that only uses operands A and B, and GGX_F1_NARG is a FORM\r\n1 instruction that uses no operands. Classifying instructions using\r\nthese values will simplify disassembly. The print_insn_ggx() function\r\nnow includes support for disassembling generic GGX_F1_NARG\r\ninstructions (of which \"bad\" is now a member). We'll add more\r\ninstructions types as our port develops.\r\n\r\nWhen I started this series I mentioned that we would only add\r\ninstructions as required by the compiler. However, that's not quite\r\ntrue. We're going to add two basic instruction prior to building the\r\ncompiler so we can assemble and run our first program on a\r\nsimulator. Our first good (or, at least, non-\"bad\") instruction will\r\nbe \"load immediate\". We'll do that tomorrow.\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-07-src.patch\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPatch 8: A First Real Instruction\r\n---------------------------------\r\n\r\nYesterday we decided that the ggx core will have eight general purpose\r\nregisters. Let's name them $r0 to $r7.\r\n\r\nIt's time to add our first real instruction. We're going to implement\r\na \"Load Immediate\" instruction. This will extract an integer value\r\nfrom the instruction stream and load it into a register. We'll use\r\nsyntax like this:\r\n\r\n    ldi.l $r1, 0x555\r\n\r\nThe \".l\" suffix means \"long word\" (4 bytes). So \"ldi.l\" is \"Load\r\nImmediate Long Word\", and \"ldi.l $r1, 0x555\" will put the 4-byte value\r\n0x555 into register $r1.\r\n\r\nWe're going to encode the \"0x555\" part in the instruction stream\r\nimmediately after the 16-bit instruction, so \"ldi.l $r1, 0x555\" is\r\nreally a 48-bit instruction.\r\n\r\nNow we need to implement our first fixup. A fixup is a placeholder in\r\nthe instruction stream that gets populated with a value at the tail\r\nend of assembly. In this case we need a fixup to tell the assembler\r\nhow to encode our 0x555 immediate value in the instruction\r\nstream. Some fixups can't be resolved at assembly time, so the the\r\nassembler turns them into \"relocations\" (or relocs).\r\n\r\nConsider, for instance, the following instruction:\r\n\r\n    _start:     ldi.l $r1, _start+0x10\r\n\r\nWe don't know where _start will end up in memory until link time, so\r\nthe assembler generates a reloc that gets computed at link time.\r\n\r\nWe don't need to worry too much about how this all works. However, we\r\ndo need to describe the basic relocs required by our port. In this\r\ncase, we simply need a 32-bit reloc that we'll call R_GGX_DIR32. This\r\npatch contains all of the bfd changes necessary to implement 32-bit\r\nrelocations. Eventually we'll need a different one to fill the 12-bit\r\nvalue part of FORM 2 instructions.\r\n\r\nWe also define a new instruction type, GGX_F1_A4, which is FORM 1\r\ninstruction using operand A followed by a 4-byte value. We teach\r\nopcodes how to disassemble GGX_F1_A4 instructions, and we teach the\r\nassembler how to parse and encode them.\r\n\r\nFinally, we update our opcode table to include \"ldi.l\", defining it as\r\na GGX_F1_A4 instruction.\r\n\r\nHere are our main tools in action: the assembler, linker and objdump:\r\n\r\n\r\n    $ cat foo.s\r\n            .global _start\r\n    .text\r\n    _start: ldi.l $r1, 0x555\r\n            ldi.l $r2, 0x111+0x222\r\n            ldi.l $r3, _start+0x10\r\n    $ ggx-elf-as -o foo.o foo.s && ggx-elf-ld -o foo foo.o\r\n    $ ggx-elf-objdump -d foo\r\n    \r\n    foo:     file format elf32-ggx\r\n    \r\n    Disassembly of section .text:\r\n    \r\n    00001054 <_start>:\r\n        1054:       00 40 00 00     ldi.l   $r1, 0x555\r\n        1058:       05 55\r\n        105a:       00 80 00 00     ldi.l   $r2, 0x333\r\n        105e:       03 33\r\n        1060:       00 c0 00 00     ldi.l   $r3, 0x1064\r\n        1064:       10 64 \r\n\r\nFantastico! Tomorrow we'll add one more unsolicited instruction, and\r\nthen we'll build our simulator...\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-08-src.patch\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPatch 9: Move It\r\n----------------\r\n\r\nWe're adding one more instruction before we move on to the simulator:\r\nregister-to-register move.\r\n\r\n    mov $rA, $rB\r\n\r\nThis simply copies the contents of register B into register A. The\r\npatch would be tiny except that this is our first GGX_F1_AB\r\ninstruction (a FORM 1 instruction using only two operands) and we need\r\nto tell opcodes and gas how to disassemble/assemble them.\r\n\r\nThe next two days are going to be really cool. Tomorrow we'll be\r\nrunning code on a simulator, and then we'll start building our C\r\ncompiler!\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-09-src.patch\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPatch 10: Time to Simulate\r\n--------------------------\r\n\r\nThere are many useful and interesting simulator infrastructures out\r\nthere. However, in the interest of simplicity, we'll use the sim\r\ninfrastructure associated with gdb in the src tree.\r\n\r\nToday's patch provides a minimal simulator for ggx. Once applied, we\r\ncan start running code like so...\r\n\r\n\r\n    $ cat foo.s\r\n    .section .bss\r\n            .long   0x00\r\n            .global _start\r\n    .text\r\n    _start: ldi.l $r1, 0x555\r\n            ldi.l $r2, 0x111+0x222\r\n            ldi.l $r3, _start+0x10\r\n            mov $r4, $r3\r\n            bad\r\n    $ ggx-elf-as -o foo.o foo.s && ggx-elf-ld -o foo foo.o\r\n    $ ggx-elf-run -t foo\r\n    # set pc to 0x1074\r\n    # 0x00001074: $r1 = 0x555\r\n    # 0x0000107a: $r2 = 0x333\r\n    # 0x00001080: $r3 = 0x1084\r\n    # 0x00001086: $r4 = $r3 (0x1084)\r\n    program stopped with signal 4.\r\n\r\nI had to manually create a .bss section because the simulator\r\ncurrently requires one. Also note how execution was terminated. Since\r\nwe're simulating a processor and not just running a program, there's\r\nno real way to end the simulation. I solved this problem by ending the\r\nprogram with a \"bad\" instruction. The simulator currently turns that\r\ninto a simulated SIGILL and halts execution. Finally, the \"-t\" option\r\nturns on instruction tracing, otherwise there would be no output.\r\n\r\nThe simulator itself is a very simple interpreter. It consists largely\r\nof a loop within which we switch on the next instruction opcode. To\r\nadd a new instruction we simply add a new case to the switch\r\nstatement. The src/sim infrastructure handles pretty much everything\r\nelse.\r\n\r\nThis simulator uses gdb's standard interfaces, so it should link\r\ncleanly into a future ggx-elf-gdb port. It should also be able to\r\nintegrate it into the board-level simulator sid should that be\r\ndesired.\r\n\r\nThis is the largest patch of the bunch, mostly because there's a lot\r\nof basic infrastructure we need to implement in order to get a working\r\nsim.\r\n\r\nTo recap, now we have gas, ld, binutils and a simulator for the ggx\r\narchitecture which currently only has two real instructions (load\r\nimmediate and register-to-register move). Tomorrow we'll have our\r\nfirst go at a C compiler. This is when things really start evolving\r\nfaster.\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-10-src.patch\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPatch 11: The Start of a C Compiler\r\n-----------------------------------\r\n\r\nWe're building our compiler today...\r\n\r\nFirst, check out the GCC tree:\r\n$ svn -q checkout svn://gcc.gnu.org/svn/gcc/trunk gcc\r\nApply the attached patch, then configure and build like so...\r\n\r\n    $ configure --target=ggx-elf --languages=c\r\n\r\nThis tells the build system to generate a C compiler for the ggx-elf\r\narchitecture.\r\n\r\nRunning \"make\" will build the compiler driver (gcc) and C compiler\r\n(cc1) but fail during the libgcc build. libgcc is a runtime support\r\nlibrary and contains things like floating point emulation routines for\r\nsystems that don't have hardware floating point support.\r\n\r\nThe plan now is to get basic functionality working in cc1 manually,\r\nthen we'll build libgcc, then newlib and libgloss.\r\n\r\nHere are some things we're changing in our architecture today...\r\n\r\nWe're renaming registers $r0..$r7 to $fp, $sp, $r0..$r5. $fp will be\r\nthe frame pointer, $sp will be the stack pointer, and $r0..$r5 remain\r\ngeneral purpose registers (src tree patch to follow). If you look\r\ncarefully, you'll see that I've also defined a $pc register, which is\r\nthe program counter. It's not a real register, but defining one for\r\nthe purposes of the compiler makes certain things easier.\r\n\r\nWe've also defined additional features of the ABI: 32-bit ints and\r\nlongs, 16-bit short, 8-bit char, chars are signed by default, 32-bit\r\nfloats, 64-bit doubles and long doubles, and 64-bit long longs. These\r\nare typical settings for 32-bit word systems.\r\n\r\nThis patch also makes some initial decisions about the calling\r\nconvention. We don't have an over-abundance of registers, so for now\r\nwe're only going to pass the first two 32-bits of function arguments\r\nin registers $r1 and $r2 and the rest will go on the stack. Integral\r\nvalues smaller than 32-bits will be promoted to 32-bits. Scalar return\r\nvalues will go in $r0 (and $r1 if required).\r\n\r\nIf you look at the patch, you'll see that a number of target macros\r\nare set to abort(). My focus was to get to a cc1 that builds as\r\nquickly as possible. We can fix up these aborting macros with real\r\ndefinitions as required.\r\n\r\nThe compiler also provides a couple of aborting instruction\r\npatterns. Even the most basic source file won't compile without these\r\ndefinitions. However, we don't really need them for code generation\r\nyet which is why they're aborting.\r\n\r\nBut now, finally.. \r\n\r\n    $ cat foo.c\r\n    int myint;\r\n    short myshort;\r\n    double mydouble;\r\n    $ ./cc1 -quiet foo.c\r\n    $ ggx-elf-as foo.s -o foo.o && ggx-elf-nm foo.o\r\n    00000008 C mydouble\r\n    00000004 C myint\r\n    00000002 C myshort\r\n \r\nThat's about all it will do for now. Anything else aborts during\r\ncompilation. The plan now is to try fix things up as we attempt\r\ncompile increasingly complex code.\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-11-gcc.patch\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPatch 12: Building and Running our First C Program\r\n---------------------------------------------------\r\n\r\nIt's time to run our first program! Here's the C code: \r\n\r\n    void _start()\r\n    {\r\n      /* Initialize the stack and frame pointers. */\r\n      asm (\"ldi.l  $sp, 0x30000\");\r\n      asm (\"ldi.l  $fp, 0x0\");\r\n    \r\n      /* Call main()  */\r\n      main();\r\n    \r\n      /* Terminate execution.  */\r\n      asm (\"bad\");\r\n    }\r\n    \r\n    int main()\r\n    {\r\n      return 0x555;\r\n    }\r\n    \r\n    int x; /* because the sim requires a .bss section. */\r\n\r\nWe have no C runtime library support yet, so we have to do things\r\nmanually in our own hand-coded _start function. This would normally\r\ninitialize the stack and frame pointers, and then clear .bss before\r\ncalling main(). Unfortunately we don't have any instructions for\r\nwriting to memory yet, so we won't be clearing .bss. There's a \"bad\"\r\ninstruction after the call to main() in order to terminate the\r\nsimulator with SIGILL. I think there's a cleaner way to terminate\r\nsimulation, but it will have to wait 'til we're linking with libgloss.\r\n\r\nThis code requires two new ggx instructions: jsra and ret. jsra is\r\n\"Jump to SubRoutine at Absolute address\" and ret is a \"RETurn from\r\nsubroutine\" instruction. jsra is a new instruction type:\r\nGGX_F1_4. This is a FORM 1 instruction with no register operands\r\nfollowed by a 4-byte value (the target function address). jsra\r\nperforms the following actions:\r\n\r\n\r\n    push the return address (next instruction) on the stack\r\n    push $fp on the stack\r\n    set $pc to target address\r\n\r\nret does the opposite...\r\n\r\n    pop the old frame pointer into $fp\r\n    pop the return address into $pc\r\n\r\nPretty simple! Keep in mind, however, that this isn't nearly enough\r\nsupport for proper function calls. We still need to save callee saved\r\nregisters on the stack and allocate space for local variables. Let's\r\ndo that later when we actually have instructions for writing to\r\nmemory. We'll just avoid using local variables for now.\r\n\r\n    $ ./cc1 -quiet foo.c\r\n    $ ggx-elf-as -o foo.o foo.s\r\n    $ ggx-elf-ld -o foo foo.o\r\n    $ ggx-elf-objdump -d foo\r\n    foo:     file format elf32-ggx\r\n    \r\n    Disassembly of section .text:\r\n    \r\n    00001074 <_start>:\r\n        1074:       00 40 00 03     ldi.l   $sp, 0x30000\r\n        1078:       00 00\r\n        107a:       00 00 00 00     ldi.l   $fp, 0x0\r\n        107e:       00 00\r\n        1080:       04 00 00 00     jsra    0x108a\r\n        1084:       10 8a\r\n        1086:       08 00           bad\r\n        1088:       06 00           ret\r\n    \r\n    0000108a <main>:\r\n        108a:       00 80 00 00     ldi.l   $r0, 0x555\r\n        108e:       05 55\r\n        1090:       06 00           ret\r\n    $ ggx-elf-run -t foo\r\n    # set pc to 0x1074\r\n    # 0x00001074: $sp = 0x30000\r\n    # 0x0000107a: $fp = 0x0\r\n    # 0x00001080: jumping to subroutine 0x108a\r\n    # 0x0000108a: $r0 = 0x555\r\n    # 0x00001090: returning to 0x1086\r\n    program stopped with signal 4.\r\n\r\nSee how we're returning 0x555 by loading it into $r0?\r\n\r\nThere are two patches today. The src tree patch does some register\r\nrenaming, and adds jsra and ret instruction support. The second patch\r\nupdates some of the target macros and adds a couple of instruction\r\npatterns in the machine description for calls and returns.\r\n\r\nToday's patch is available in the ggx patch archive.\r\n\r\nMore fun tomorrow....\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-12-src.patch\r\n* http://github.com/atgreen/ggx/blob/master/ggx-12-gcc.patch\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPatch 13: Function Prologues and Epilogues\r\n------------------------------------------\r\n\r\nToday's patch introduces a first go at proper function prologues and\r\nepilogues. The function prologue is responsible for saving\r\ncallee-saved registers and allocating stack space for local\r\nvariables. The function epilogue is responsible for restoring\r\ncallee-saved registers and executing a ret instruction.\r\n\r\nI found this to be the toughest thing to get right so far. The trick I\r\nlearned is that you have to tell the compiler about registers that\r\ndon't really exist. In this case, we tell the compiler about an\r\nargument pointer register and a second frame pointer. The ggx port\r\ncalls these \"?ap\" and \"?fp\". I prefixed them with ? because they won't\r\nreally exist in the architecture and we'll never generate code with\r\nthem. The compiler assumes that these are real registers until close\r\nto the end of compilation when it has to replace ?fp and ?ap\r\nreferences with $fp and $sp by computing the difference between\r\nthem. This description really doesn't do it justice. Just believe me\r\nwhen I say it was tricky to get right.\r\n\r\nWe're introducing three new instructions in this patch: push, pop and\r\nadd.l. They look like this:\r\n\r\n    push  $sp, $r2\r\n    pop   $sp, $r2\r\n    add.l $r1, $r2, $r3\r\n\r\nThe push instruction in this example will decrement $sp by four and\r\nstore $r2 at memory location $sp. (Note that the stack is growing\r\ndownwards, just like on most ports).\r\n\r\nThe pop instruction here will load $r2 with the 4-byte value stored at address $sp, and increment $sp by four.\r\n\r\nAnd, finally, add.l adds the contents of $r2 to $r3 and saves the answer in $r1.\r\n\r\nWe use push and pop to save and restore callee-saved registers. The\r\nadd.l instruction was introduced to perform stack adjustments in the\r\nprologue/epilogue.\r\n\r\nWe'll end up with push/pop pair for each callee-saved register. I\r\nthink we can do better some time down the road by using a single\r\ninstruction to push/pop all callee-saved registers in one go. The way\r\nwe do this by encoding a bitmask of the registers we need to save in\r\nthe push instruction (and similarly in the pop instruction). Let's\r\nsave that trick of later.\r\n\r\nNow, given this C code:\r\n\r\n    int foo(int, int);\r\n    int main()\r\n    {\r\n      return foo (111, 222);\r\n    }\r\n    \r\nWe get:\r\n\r\n    main:\r\n            push   $sp, $r1\r\n            ldi.l  $r0, 111\r\n            ldi.l  $r1, 222\r\n            jsra   foo\r\n            ldi.l  $r5, -4\r\n            add.l  $sp, $fp, $r5\r\n            pop    $sp, $r1\r\n            ret\r\n    \r\nYou'll notice that we're saving and restoring the caller's $r1, but\r\nnot $r0. This is because the compiler knows that $r0 may be used to\r\nreturn values and shouldn't assume it will survive function\r\ncalls. (Note: just as I was writing this, I realized that 64-bit\r\nintegrals may be returned in $r0 and $r1, so $r1 shouldn't be\r\ncallee-saved either. I'll fix this tomorrow.)\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-13-src.patch\r\n* http://github.com/atgreen/ggx/blob/master/ggx-13-gcc.patch\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPatch 14: Loading and Storing\r\n-----------------------------\r\n\r\nIt's time to implement loading and storing for our load-store\r\narchitecture! Today's patch introduces 4-byte memory loads and stores.\r\n\r\nThe compiler uses these to read and write global variables, as well as\r\nto load and store local, temps and function arguments to and from the\r\nstack.\r\n\r\nWe're introducing three new instructions in this patch: ld.l, lda.l,\r\nst.l, and sta.l. They look like this:\r\n\r\n\r\n    ld.l  $r1, ($r2)\r\n    lda.l $r1, myvar\r\n    st.l  ($r1), $r2\r\n    sta.l myvar, $r2\r\n\r\nThe ld.l instruction loads a long word into $r1 from the memory\r\nlocation stored in $r2. lda.l is a Load Absolute instruction, and\r\nloads 4-bytes from the address \"myvar\" (the address is encoded in this\r\n48-bit instruction). st.l and sta.l are the obvious \"store\" versions\r\nof these instructions. Eventually we'll add .s and .b versions of\r\nthese instructions to load/store 16- and 8-bit values.\r\n\r\nWe had to add new instruction types to handle instructions with\r\nindirect operands (in parenthesis). We also added our first custom\r\nconstraint ('W') in the compiler's machine description to implement\r\nthe simple patterns for indirect loads and stores. None of this was\r\nvery difficult.\r\n\r\nThis patch also includes a few little fixes. For instance, the jsra\r\ninstruction is now responsible for setting $fp to $sp and I fixed the\r\norder in which we increment the stack pointer when pushing values in\r\njsra.\r\n\r\nNow that we can load and store, we're able to compile and run programs\r\nlike this:\r\n\r\n\r\n    int g;\r\n    \r\n    int add(int a, int b, int c, int d, int e, int f)\r\n    {\r\n      return a + b + c + d + e + f + g;\r\n    }\r\n    \r\n    int main()\r\n    {\r\n      g = 7;\r\n      return (add (1, 2, 3, 4, 5, 6));\r\n    }\r\n\r\nThis is what the compiler now generates for main() (with annotations\r\nby hand):\r\n\r\n    main:\r\n            # allocate stack space for outgoing function args\r\n            ldi.l  $r5, -16\r\n            add.l  $sp, $sp, $r5\r\n            # store 7 in global variable 'g'\r\n            ldi.l  $r0, 7\r\n            sta.l  g, $r0\r\n            # store arg 3 on stack\r\n            ldi.l  $r0, 3\r\n            st.l   ($sp), $r0\r\n            # store arg 4 on stack\r\n            ldi.l  $r0, 4\r\n            add.l  $r1, $sp, $r0\r\n            ldi.l  $r0, 4\r\n            st.l   ($r1), $r0\r\n            # store arg 5 on stack\r\n            ldi.l  $r0, 8\r\n            add.l  $r1, $sp, $r0\r\n            ldi.l  $r0, 5\r\n            st.l   ($r1), $r0\r\n            # store arg 6 on stack\r\n            ldi.l  $r0, 12\r\n            add.l  $r1, $sp, $r0\r\n            ldi.l  $r0, 6\r\n            st.l   ($r1), $r0\r\n            # load args 1 and 2 into registers\r\n            ldi.l  $r0, 1\r\n            ldi.l  $r1, 2\r\n            # call the add() function and return the result\r\n            jsra   add\r\n            ret\r\n\r\nWhile this certainly works (we can compile, assemble, link and then\r\nrun on our simulator), it's far too long. Almost all of this code is\r\ndedicated to storing operands 3 through 6 to the stack (1 and 2 are\r\npassed in registers $r0 and $r1). We can do better by introducing\r\nindirect offset addressing. That's what we'll do tomorrow.\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-14-src.patch\r\n* http://github.com/atgreen/ggx/blob/master/ggx-14-gcc.patch\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPatch 15: A Simpler Way to Load and Store\r\n-----------------------------------------\r\n\r\nYesterday's patch introduced basic load and store instructions, but\r\nwith only two addressing modes: absolute and indirect. Storing a value\r\n8-bytes into the stack looked like this:\r\n\r\n    ldi.l  $r0, 8           # load offset into $r0\r\n    add.l  $r1, $sp, $r0    # compute address\r\n    ldi.l  $r0, 5           # load the value we want to save\r\n    st.l   ($r1), $r0       # store it\r\n\r\nWe're going to introduce a new addressing mode to simplify this, so the code now looks like this:\r\n\r\n    ldi.l  $r0, 5\r\n    sto.l  8($sp), $r0\r\n\r\nThis makes \"st.l ($sp), $r0\" equivalent to \"sto.l 0($sp), $r0\".\r\n\r\nMy plan was to only add instructions as required by the compiler. I'm\r\ngoing against plan here, as we don't absolutely need to add this new\r\ninstruction. However, I was having a tough time following all of the\r\nloads and adds while debugging code generation and this makes the code\r\nmuch more readable. I'll try not to do these kinds of premature\r\noptimizations going forward, as I want to optimize the ISA and\r\nencodings based on real-world code generation. You'll just have to\r\nforgive me this one indulgence for now.\r\n\r\nI'd also like to point out that I'm using different instruction names\r\nfor different addressing modes: st for store indirect, sta for store\r\nabsolute, and sto for store offset (similarly for ld, lda and\r\nldo). This is not strictly necessary. We should be able to overload\r\nthe name and distinguish between sto, st and sta based on instruction\r\noperands. However, gas doesn't provide much infrastructure for fancy\r\ninstruction parsing, so I decided to go the easy way and give these\r\ninstructions different names.\r\n\r\nHere's a side-by-side comparison with code we generated yesterday for\r\nmain()\r\n\r\n\r\n    main:                           main:\r\n            ldi.l  $r5, -16                 ldi.l  $r5, -16\r\n            add.l  $sp, $sp, $r5            add.l  $sp, $sp, $r5\r\n            ldi.l  $r0, 7                   ldi.l  $r0, 7\r\n            sta.l  g, $r0                   sta.l  g, $r0\r\n            ldi.l  $r0, 3                   ldi.l  $r0, 3\r\n            st.l   ($sp), $r0               st.l   $(sp), $r0\r\n            ldi.l  $r0, 4\r\n            add.l  $r1, $sp, $r0\r\n            ldi.l  $r0, 4                   ldi.l  $r0, 4\r\n            st.l   ($r1), $r0               sto    4($sp), $r0\r\n            ldi.l  $r0, 8\r\n            add.l  $r1, $sp, $r0                   \r\n            ldi.l  $r0, 5                   ldi.l  $r0, 5\r\n            st.l   ($r1), $r0               sto.l   8($sp), $r0\r\n            ldi.l  $r0, 12\r\n            add.l  $r1, $sp, $r0\r\n            ldi.l  $r0, 6                   ldi.l  $r0, 6\r\n            st.l   ($r1), $r0               sto.l  12($sp), $r0\r\n            ldi.l  $r0, 1                   ldi.l  $(r0), 1\r\n            ldi.l  $r1, 2                   ldi.l  $(r1), 2\r\n            jsra   add                      jsra   add\r\n            ret                             ret\r\n\r\nThe new code, on the right, only saves us 6 instructions. It may not\r\nseem like much, but it's enough to make a really big difference when\r\nyou're tracing through simulator output trying to debug code\r\ngeneration errors.\r\n\r\nWe've got a small handful of instructions now, but only for\r\nstraight-line code. Tomorrow we'll add compare and branch\r\ninstructions, and soon we'll be building libgcc: GCC's runtime support\r\nlibrary.\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-15-src.patch\r\n* http://github.com/atgreen/ggx/blob/master/ggx-15-gcc.patch\r\n\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPatch 16: if... then... else...\r\n-------------------------------\r\n\r\nArchitectures with no if-then-else capability are pretty boring, so\r\ntoday we're adding compare and branch instructions.\r\n\r\nIn addition to the new instructions, we'll be adding a condition code\r\nregister. This register holds a series of bits that will be set by our\r\ncompare instruction. The bits currently are:\r\n\r\n* 00001: Greater Than, Signed\r\n* 00010: Less Than, Signed\r\n* 00100: Equal\r\n* 01000: Greater Than, Unsigned\r\n* 10000: Less Than, Unsigned\r\n\r\nWe could also probably benefit from a \"Zero\" bit, and we may want to\r\nsqueeze arithmetic overlow in there at some point as well, but this\r\ncollection of 5 bits is certainly good enough for now.\r\n\r\nWe're not currently exposing this register to the programmer. It's\r\njust a bit of internal global state that's implemented in the\r\nsimulator. This may also change at some point.\r\n\r\nGCC supports 10 conditional branch patterns: beq, bne, blt, bgt, bltu,\r\nbgtu, bge, ble, bgeu, bleu. They all do the obvious things. For\r\ninstance, bleu is Branch if Less or Equal (Unsigned). I've implemented\r\nall 10 as instructions even though this isn't really necessary. For\r\ninstance, bgt is essentially ble after you swap the operands. I didn't\r\nwant to get too clever at this point, and I still have plenty of\r\nopcode space. Let's just keep this in our back pocket if we start\r\nfeeling opcode space pressure.\r\n\r\nYou'll also note that I encoded all of these branch instructions as\r\nGGX_F1_AB4 GGX_F1_4. This means they have two no operands and are\r\nfollowed by a 4-byte value (the target address). This is pretty\r\nwasteful. We'll likely end up with a shorter PC-relative branch\r\ninstruction, but I want to actually measure things before I added this\r\ncomplexity (for instance, how many bits are required to represent X%\r\nof all PC-relative branches?).\r\n\r\nHere's some sample source and output:\r\n\r\n    int lessthan (int x, int y)\r\n    {\r\n      return (x < y);\r\n    }\r\n    \r\n    lessthan:\r\n            ldi.l  $r5, 0\r\n            cmp    $r1, $r0\r\n            bge    .L2\r\n            ldi.l  $r5, 1\r\n    .L2:\r\n            mov    $r0, $r5\r\n            ret\r\n\r\nThis patch also adds jsr and jmp instructions. They both use register\r\noperands containing the targe t address. Both were pretty straight\r\nforward to implement and required to get to this next step...\r\n\r\nRunning \"make -k\" in the libgcc directory results in 116 object files!\r\n\r\nThere should be 143, so we're very close. Of the ones that are failing, they all die like so:\r\n    ../../../gcc/libgcc/../gcc/unwind-c.c: In function ‘__gcc_personality_sj0’:\r\n    ../../../gcc/libgcc/../gcc/unwind-c.c:59: internal compiler error: in emit_move_multi_word, at expr.c:3247\r\n\r\nThis error is indicative of missing \"mov\" patterns for smaller data\r\nsizes (short words and bytes). This is what we'll add tomorrow. Once\r\nwe've built libgcc, we'll move on the newlib and libgloss. We're very\r\nclose to running a real \"Hello World\" app!\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-16-src.patch\r\n* http://github.com/atgreen/ggx/blob/master/ggx-16-gcc.patch\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPatch 17: Bytes, Shorts, and Some Cleanup\r\n-----------------------------------------\r\n\r\nWe hit an important milestone today!...\r\n\r\nYesterday we tried building libgcc after adding compare and branch\r\ninstructions. The compiler built a few files but eventually failed\r\nbecause it didn't know how to load and store values smaller than\r\n4-bytes. Today we'll introduce patches for dealing with these 16-bit\r\n(.s) and 8-bit (.b) values.\r\n\r\nThe new instructions are directly analogous to their \".l\"\r\ncounterparts: ldi.b, ld.b, lda.b, st.b, sta.b, ldi.s, ld.s, lda.s,\r\nst.s, and sta.s.\r\n\r\nOnce we add these instructions almost all of libgcc builds. The\r\ncompiler just asks for one more instruction before it'll finish the\r\njob: an unconditional jump to an address stored in a register\r\n(jmp). Ok, done!\r\n\r\nFinally, all 143 object files build to create libgcc.a! [sound of\r\nchampagne bottle popping open]\r\n\r\nDespite hitting this milestone, today's patches are a little boring,\r\nso I've included a second patch to GCC.\r\n\r\nOne of the problems with coding by example is that you have to know\r\nwhich examples to pick in order to be successful. Today's second GCC\r\npatch fixes a poor choice I made in yesterday's compare and branch\r\npatch.\r\n\r\nI had implemented compare/branch using \"cc0\", a magic condition code\r\nregister that only the compiler knows about. GCC has plenty of special\r\ncase logic to deal with this cc0 register, and the GCC hackers hate\r\nit. The preferred way to deal with this is to create a normal register\r\nto hold condition codes (ggx's is called \"?cc\"). It still only exists\r\nin the mind of the compiler (we'll never generate code referencing\r\nit), but I'm told it greatly simplifies things for the compiler\r\ndevelopers. Does it change how the compiler optimizes? My\r\nunderstanding is that the underlying logic is more sane, but the\r\noutput should be (almost?) identical. (comments welcome if I have this\r\nwrong) Despite the strong desire to rid GCC of cc0 ports, I think most\r\na few of them still use cc0. Apparently, de-cc0'ing a mature port is a\r\nlot of work (another good reason to get this right from day one!), so\r\nI don't know if cc0 will be officially deprecated any time soon.\r\n\r\nThe second change in this patch replaces my 10 branch patterns in the\r\nmachine description with a single pattern that uses an iterator to\r\nproduce the 10 different patterns. It doesn't change the compiler's\r\nbehaviour, but it does let us rip out a bunch of repetitive code.\r\n\r\n(Thanks to Hans-Peter and Paolo for their feedback and advice on this\r\nlast patch)\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-18-src.patch\r\n* http://github.com/atgreen/ggx/blob/master/ggx-18-gcc.patch\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPatch 18: libgloss, newlib and hello.c\r\n--------------------------------------\r\n\r\nWe're almost at the next major milestone: building and running a Hello\r\nWorld program in C. But first, a quick recap...\r\n\r\nThe ggx core is a simulated 32-bit load-store von Neumann architecture\r\nprocessor. It currently has 8 32-bit general purpose registers and 37\r\ninstructions (a mix of 16- and 48-bits long).\r\n\r\nWe're 17 patches into our experiment and as of yesterday we can\r\nconfigure, build and install gas, ld, binutils, a simulator and the\r\nGCC C compiler and runtime support library. There's no doubt these\r\nthings still all need work, but today we'll turn our attention towards\r\nnewlib and libgloss.\r\n\r\nNewlib is a standard C library, much like glibc on Linux. It was\r\noriginally cobbled together by folks at Cygnus in order to offer a\r\nliberally licensed C library to their embedded tools customers. It's\r\nstill maintained by Jeff Johnston (now at Red Hat) and is widely used\r\nby embedded developers and the Cygwin community (newlib provides the\r\nstandard C library in cygwin.dll).\r\n\r\nlibgloss is a little more difficult to describe. Rob Savoye (dejagnu,\r\ngnash) once told me it was called libgloss because you use it to\r\n\"gloss\" over details when don't have an OS on your embedded system. It\r\nsits between newlib and your hardware or simulator, and exports a\r\nsystem call interface to newlib so C programs can interact with it.\r\n\r\nLet's say, for instance, that you have a MIPS-based single board\r\ncomputer with a serial port for I/O. You would need to port libgloss\r\nto that specific board so that reading and writing through newlib\r\nroutines (printf, etc) would send data up and down the board's serial\r\nport. It's an important element of what you might refer to as a Board\r\nSupport Package (BSP). In fact, the libgloss sources build a library\r\ncalled \"libbsp.a\", not \"libgloss.a\". libgloss provides a few more\r\nthings (a gdb remote protocol stub for instance), but we're not going\r\nto worry about these things for now.\r\n\r\nFor ggx, we'll need to implement some kind of trap instruction so\r\nlibgloss can talk to the simulator. Then we'll implement systems calls\r\nfor things like \"write\". In the case of \"write\" we'll send output to\r\nthe console on the machine running the sim. But let's worry about that\r\ntomorrow. I've just stuck \"bad\" instructions in libgloss' syscall\r\nstubs for now. Today's focus is to generate fully built libraries for\r\nlibgloss and newlib.\r\n\r\nThe changes are all pretty obvious, and there's lots of sample code in\r\nother ports to copy. That being said, the patches are a little on the\r\nbig side, mostly because of the new autotool generated configury.  As\r\nusual, I've placed them in the ggx patch archive.\r\n\r\nIf you apply the src patches for newlib/libgloss, then configure and\r\nbuild with ggx-elf-gcc, you'll find that you have two new libraries:\r\nlibbsp.a (from libgloss) and libc.a (from newlib). Install them now,\r\nand let's try a hello world:\r\n\r\n    #include <stdio.h>\r\n    \r\n    int main()\r\n    {\r\n      puts (\"Hello World!\");\r\n      return 0;\r\n    }\r\n \r\n\r\nIf you try compiling this like so: ggx-elf-gcc -o hello hello.c, you'll be presented with pages and pages of linker errors that look like this:\r\n\r\n    strlen.c:(.text+0x1a): undefined reference to `__andsi3'\r\n    strlen.c:(.text+0x56): undefined reference to `__ashlsi3'\r\n    strlen.c:(.text+0x5e): undefined reference to `__ashrsi3'\r\n    strlen.c:(.text+0x8e): undefined reference to `__ashlsi3'\r\n    strlen.c:(.text+0xb2): undefined reference to `__subsi3'\r\n    strlen.c:(.text+0xdc): undefined reference to `__one_cmplsi2'\r\n    strlen.c:(.text+0x116): undefined reference to `__one_cmplsi2'\r\n\r\nWhat are these, you ask? They're all references to functions that GCC\r\nis trying to use in place of missing instructions.\r\n\r\nGCC uses a clever trick during code generation. Let's say it you have\r\nsome C code that looks like this: \"a = b & c\", where a, b and c are\r\nall ints. GCC needs to generate code to \"and\" b and c together. If it\r\ncan't figure out how to do this, it will simply emit a call to a\r\nfunction with a special name (__andsi3 in this case) and hope that the\r\nuser will provide a library implementation at link time. Try poking\r\naround in the linux kernel sources and you'll see that a few ports\r\nprovide their own versions of \"missing\" instructions.\r\n\r\nIn our case, we have yet to implement any of these instructions. They\r\nrepresent (in order), logical and, arithmetic shift left, arithmetic\r\nshift right, subtraction, and bitwise \"not\". These are just the\r\nmissing instructions required by newlib's strlen(). In total, there\r\nare about 9 instructions missing in order to complete the Hello World\r\nlink. Tomorrow we'll add all 9 instructions to the ISA and link our\r\nfirst full application. But will it run? Tune in tomorrow...\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-18-src.patch\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPatch 19: Hello World!\r\n----------------------\r\n\r\nThis is it. Today we're building and running a \"Hello World\" C app on\r\nthe ggx simulator.\r\n\r\nYesterday we identified nine missing instructions required to link\r\nhello.c to newlib. They were all arithmetic and logical operators and\r\nwere simple to implement in all of the tools.\r\n\r\nToday's patch also includes a software interrupt instruction\r\n(swi). This is the instruction that ggx code will use to talk to the\r\nsimulator in order to interface with the outside world. Consider, for\r\ninstance, the primitive function \"write\"\r\n\r\n    int write (int fd, const void *buf, size_t len);\r\n\r\nWe implement a system call in libgloss like so:\r\n\r\n    /*\r\n     * Input:\r\n     * $r0      -- File descriptor.\r\n     * $r1      -- String to be printed.\r\n     * -8($fp)  -- Length of the string.\r\n     *\r\n     * Output:\r\n     * $r0    -- Length written or -1.\r\n     * errno  -- Set if an error\r\n     */\r\n\r\n    write:\r\n         swi     SYS_write /* SYS_write is a constant 5 */\r\n         ret\r\n\r\nThen the simulator's handling of the swi instruction includes a switch on the interrupt number:\r\n\r\n      case 0x5: /* SYS_write */\r\n        {\r\n            char *str = &memory[cpu.asregs.regs[3]];\r\n            /* String length is at 0x8($fp) */\r\n            unsigned count, len = EXTRACT_WORD(&memory[cpu.asregs.regs[0] + 8]);\r\n            count = len;\r\n            while (count-- > 0)\r\n                putchar (*(str++));\r\n            cpu.asregs.regs[2] = len;\r\n         }\r\n\r\nIt's not a perfect implementation (all output goes to stdout, and\r\nthere's no error checking), but it works for now.\r\n\r\nToday's patch and tests really put the toolchain through its paces, as\r\nwe'll be simulating thousands of instructions just for hello.c! Our\r\nsimulator runs to date have been limited to a dozen or so\r\ninstructions, so this is a big jump...\r\n\r\n    $ cat hello.c\r\n    #include <stdio.h>\r\n    \r\n    int main()\r\n    {\r\n      puts (\"Hello World!\");\r\n      return 0;\r\n    }\r\n    $ ggx-elf-gcc -o hello hello.c\r\n    $ ggx-elf-run hello\r\n    Hello World\r\n    $ ggx-elf-run -v hello \r\n    ggx-elf-run hello\r\n    Hello World!\r\n    \r\n    \r\n    # instructions executed        2704\r\n\r\n2704 instructions is a lot of code for just Hello World. Consider,\r\nhowever, that this includes all of the system initialization code,\r\nsuch as initializing the heap, allocating IO buffers with malloc(),\r\netc. There's a lot that has to happen before we get to printing our\r\ngreeting.\r\n\r\nTo be honest, I skipped a step in there. It's the one where running\r\n\"hello\" fails in many interesting ways and you have to debug simulator\r\ntraces. There's no avoiding this step. Just think of it as a rite of\r\npassage.\r\n\r\nIn my case, I tracked it down to bad relocation generation in the\r\nassembler and was able to fix it thanks again to #gcc IRC\r\nfolks. Today's patch includes this fix.\r\n\r\nWhen I started this series I wrote that I would show how go from\r\nnothing to running real programs on a new architecture by posting\r\ndaily patches. I think we're there, so I'm going to slow down the\r\nblogging effort. But that's not to say that I'm done with ggx. There's\r\nstill plenty to do. Here are some ideas for work items: \r\n\r\n### gcc testsuite\r\n\r\nGCC comes with a huge suite of tests to exercise code generation. The\r\nnext obvious step in the development of this toolchain is to start\r\nwhacking away at bugs identified by the testsuite. I've had a quick\r\ncrack at it, and a couple of obvious things need fixing. For instance,\r\nthere's an off-by-one error in ABI handling for vararg\r\nfunctions. There's also no support for trampolines, which are needed\r\nfor GCC's nested functions extension. Apart from that, the results\r\nlook pretty good so far.  \r\n\r\n### broader language support\r\n\r\nException handling is big issue here. The compiler needs to be taught\r\nhow to deal with C++ and Java exceptions. libffi is also needed for\r\nJava.  \r\n\r\n### gdb support\r\n\r\nThis is a tricky one for ggx. If we were working from a pre-defined\r\nISA, then I would go straight to gdb next. Stepping through code with\r\ngdb is much more productive than reading instruction traces from the\r\nsimulator. But we're not working from a pre-defined ISA with fixed\r\ninstruction encodings. We're just at a first draft of the ISA and plan\r\nto make many changes.\r\n\r\nUnfortunately, it looks like a lot of what goes into making gdb work\r\nis hard coding recognition of instruction sequences for things like\r\nlike function prologues. I don't want to have to hack gdb every time I\r\ntweak the ISA, so I'll leave this 'til much later in the game.  ISA\r\ntweaking\r\n\r\nThis is where the game really begins. Check out this chart, which\r\nshows the static frequency of instruction types used in our hello\r\napplication:\r\n\r\n[chart appears to be lost. looking for copy]\r\n\r\nThe most frequently used instruction type is GGX_F1_A4, which is a\r\n16-bit instruction with one operand followed by a 32-bit value. These\r\nare all of the \"load immediate\" and \"load absolute\" instructions. What\r\nwe'll want to do is understand everything about these instructions:\r\nhow and why they're used, and if there's anything we can do to\r\neliminate them or encode them more efficiently. We already know\r\nthere's 6-bits of waste in the first 16-bits of GGX_F1_A4 because\r\nwe're not using operands B and C. Perhaps we can use those 6-bits to\r\nhold a small constant value. That would turn some number of those\r\n48-bit load-immediate instructions into 16-bit instructions. There\r\nwill be many opportunities for improvements like this, and it should\r\nbe interesting to see how dense we can make our code.  \r\n\r\n### Run Linux!\r\n\r\nOnly half joking here. Truth be told, it builds, but we're a long way\r\nfrom booting...\r\n\r\n[chart appears to be lost. looking for copy]\r\n\r\nIt's interesting to see that the mix of instructions is completely\r\ndifferent in the kernel. The 4th and 5th most frequently used\r\ninstruction types are swapped. This demonstrates how it will be\r\nimportant to have a good mix of programs at hand while we're tweaking\r\nthe ISA.\r\n\r\nI hope some people have found this series interesting. I'm interested\r\nin hearing feedback if you are so inspired.\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-19-src.patch\r\n* http://github.com/atgreen/ggx/blob/master/ggx-19-gcc.patch\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPatch 20: The GCC Testsuite and Cooperative Multitasking\r\n--------------------------------------------------------\r\n\r\nThere's good reason to implement support for the \"write\" system call\r\nright away. It's the bare minimum required to run any of the\r\n\"c-torture/execute\" tests. This is the group of tests in GCC's\r\nextensive testsuite which require execution on the target platform.\r\n\r\nI let the gcc execution tests run last night, and this is what I got:\r\n\r\n                    === gcc Summary ===\r\n    \r\n    # of expected passes            11945\r\n    # of unexpected failures        910\r\n    # of unresolved testcases       129\r\n     \r\nNot bad for a first run! Lots of failing tests were timing out. I\r\nthink there's a bug in how we compile long long and long double\r\nsupport which is creating an infinite loop in libgcc. Or it could be a\r\nbug in the simulator. One never knows...\r\n\r\nI did find a couple of simple sim bugs, which are fixed in today's\r\npatch.\r\n\r\nI also implemented setjmp and longjmp support in newlib, and then\r\ntested with Cheap Threads.\r\n\r\nCheap Threads is a simple C library providing cooperative multitasking\r\nusing setjmp/longjmp.\r\n\r\nThis is first code I've downloaded from the net which built and ran\r\nwithout a hitch:\r\n\r\n    $ ggx-elf-gcc -DCT_RETURN -c *.c\r\n    $ ggx-elf-gcc -o demo1 demo1.o cterror.o  ctsched.o ctassert.o ctalloc.o  ctmemory.o ctsubscr.o\r\n    $ ggx-elf-run -v demo1\r\n    ggx-elf-run demo1\r\n    \r\n    Cheap threads demo #1\r\n    Hello from thread A\r\n    This is coming from thread B\r\n    Hello from thread A\r\n    This is coming from thread B\r\n    Hello from thread A\r\n    This is coming from thread B\r\n    Hello from thread A\r\n    This is coming from thread B\r\n    Hello from thread A\r\n    This is coming from thread B\r\n    This is coming from thread B\r\n    This is coming from thread B\r\n    This is coming from thread B\r\n    \r\n    Maximum memory pools registered: 0\r\n    Total memory allocations: 2\r\n    Maximum outstanding memory allocations: 2\r\n    \r\n    \r\n    # instructions executed       44631\r\n\r\n44k instructions! This is most we've run so far...\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-20-src.patch\r\n\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n\r\nPatch 21: Trampolines, Benchmarks, and Rebasing Patches\r\n-------------------------------------------------------\r\n\r\nSomewhere along the line I botched one of my gcc patches and people\r\nhave been complaining that they don't all apply nicely. Well today I'm\r\nposting two new big patches for src and gcc. These patches apply\r\nagainst the latest src and gcc development sources and contain all of\r\nthe work to date.\r\n\r\nThe patches also include stdarg and trampoline support, my lazy gdb\r\nport, and a few simulator fixes (like sta.b should actually store a\r\nbyte, not a word!). This brings the gcc testsuite's unexpected error\r\ncount down to 315. Looking good!\r\n\r\nA quick scan of the remaining test failures tells me that something is\r\namiss with passing and returning aggregate types.\r\n\r\nI've also been thinking about how to measure results of ISA\r\nchanges. In a perfect world, EEMBC benchmarks would be freely\r\navailable for all to use. EEMBC provides a terrific collection of\r\nbenchmarks that are representative of different industries, and are\r\nall designed to build and run on bare metal embedded targets.\r\n\r\nThere's a Free work-alike to EEMBC called MiBench. The problem with\r\nthe MiBench benchmarks is that they aren't designed to run on bare\r\nmetal systems. For instance, they use file I/O to read and write\r\nbenchmark data. So right now I think I have three options:\r\n\r\n* Modify MiBench to work more like EEMBC and run on bare metal.\r\n* Enhance my libgloss stubs to fake file I/O by using the host filesystem.\r\n* Port a simple OS like eCos to ggx, and then run that on qemu (using src/sim as the simulation core).\r\n\r\nI don't know which way to go yet. Suggestions?\r\n\r\nPatches:\r\n* http://github.com/atgreen/ggx/blob/master/ggx-21-src.patch\r\n* http://github.com/atgreen/ggx/blob/master/ggx-21-gcc.patch\r\n\r\n\r\nFIN.\r\n\r\n\r\nThe Adventure Continues at http://github.com/atgreen/moxiedev\r\n","tagline":"How To Retarget the GNU Toolchain in 21 Patches","google":"UA-32654596-1","note":"Don't delete this file! It's used internally to help with page regeneration."}